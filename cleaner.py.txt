import csv, io, re

RE_EMAIL = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")

def normalize_headers(headers):
    return [h.strip().lower().replace(" ", "_") for h in headers]

def clean_row(row: dict):
    row = {k: (v.strip() if isinstance(v, str) else v) for k,v in row.items()}
    if "amount" in row and row["amount"]:
        row["amount"] = f"{float(row['amount']):.2f}"
    if "email" in row and row["email"] and not RE_EMAIL.match(row["email"]):
        raise ValueError(f"invalid email: {row['email']}")
    return row

def validate_required(row, required_cols):
    missing = [c for c in required_cols if row.get(c, "") == ""]
    if missing:
        raise ValueError(f"missing required: {','.join(missing)}")

def process_csv(content: bytes, required_cols):
    buf = io.StringIO(content.decode("utf-8"))
    reader = csv.DictReader(buf)
    reader.fieldnames = normalize_headers(reader.fieldnames or [])
    cleaned, bad, seen = [], [], set()

    for r in reader:
        try:
            r = {k: r.get(k,"") for k in reader.fieldnames}
            r = clean_row(r)
            validate_required(r, required_cols)
            key = (r.get("id"), r.get("email"))
            if key in seen: continue
            seen.add(key)
            cleaned.append(r)
        except Exception as e:
            r["_error"] = str(e)
            bad.append(r)

    return to_csv(reader.fieldnames, cleaned), (to_csv(reader.fieldnames+["_error"], bad) if bad else None)

def to_csv(headers, rows):
    out = io.StringIO()
    writer = csv.DictWriter(out, fieldnames=headers, extrasaction="ignore")
    writer.writeheader()
    for r in rows: writer.writerow(r)
    return out.getvalue().encode("utf-8")
